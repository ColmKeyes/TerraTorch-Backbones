# EarthMind to TerraTorch Integration: R&D Testing Plan
*Focused on core integration and testing for research and development*

## Objective
Test the EarthMind model using TerraTorch framework to evaluate compatibility, performance, and potential for geospatial tasks.

## Phase 1: Basic Setup
### 1.1 TerraTorch Installation
```bash
python -m venv terratorch-env
source terratorch-env/bin/activate
git clone https://github.com/IBM/terratorch.git
cd terratorch
pip install -e .
```

### 1.2 Simple Project Structure
```
earthmind/
├── terratorch/
├── configs/
│   └── earthmind_config.yaml
├── scripts/
│   └── test_earthmind.py
└── src/
    └── earthmind_backbone.py
```

## Phase 2: EarthMind Integration
### 2.1 Register EarthMind as Backbone
```python
# src/earthmind_backbone.py
from terratorch.registry import BACKBONE_REGISTRY
from transformers import AutoModel

@BACKBONE_REGISTRY.register("earthmind_v1")
def build_earthmind_backbone(pretrained=True, **kwargs):
    """Register EarthMind with TerraTorch"""
    model = AutoModel.from_pretrained("shuyansy/EarthMind-1.0-base")
    return model.vision_model
```

### 2.2 Basic Configuration
```yaml
# configs/earthmind_config.yaml
model:
  backbone:
    type: earthmind_v1
    pretrained: true
  decoder:
    type: unet_decoder
    in_channels: 768  # EarthMind output channels
    num_classes: 2    # For binary classification testing

training:
  batch_size: 2
  learning_rate: 1e-4
  max_epochs: 5
```

## Phase 3: Testing Script
### 3.1 Simple Test Implementation
```python
# scripts/test_earthmind.py
import torch
from terratorch.registry import BACKBONE_REGISTRY
from terratorch.models import build_model
import yaml

def test_earthmind_integration():
    """Test basic EarthMind integration with TerraTorch"""
    
    # Load config
    with open('configs/earthmind_config.yaml', 'r') as f:
        config = yaml.safe_load(f)
    
    # Test backbone registration
    backbone = BACKBONE_REGISTRY.get("earthmind_v1")()
    print(f"Backbone loaded: {type(backbone)}")
    
    # Test with dummy input
    dummy_input = torch.randn(1, 3, 224, 224)
    output = backbone(dummy_input)
    print(f"Output shape: {output.shape}")
    
    # Test full model if possible
    try:
        model = build_model(config['model'])
        model_output = model(dummy_input)
        print(f"Full model output shape: {model_output.shape}")
    except Exception as e:
        print(f"Full model test failed: {e}")

if __name__ == "__main__":
    test_earthmind_integration()
```

## Phase 4: Basic Evaluation
### 4.1 Performance Testing
```python
# Add to test script
def benchmark_basic_performance():
    """Basic performance benchmarking"""
    import time
    
    backbone = BACKBONE_REGISTRY.get("earthmind_v1")()
    backbone.eval()
    
    # Warmup
    dummy_input = torch.randn(1, 3, 224, 224)
    with torch.no_grad():
        for _ in range(5):
            _ = backbone(dummy_input)
    
    # Timing test
    start_time = time.time()
    with torch.no_grad():
        for _ in range(10):
            output = backbone(dummy_input)
    end_time = time.time()
    
    avg_time = (end_time - start_time) / 10
    print(f"Average inference time: {avg_time:.4f} seconds")
    print(f"Memory usage: {torch.cuda.max_memory_allocated() / 1e9:.2f} GB")
```

## Implementation Steps
### Week 1: Core Integration
1. Set up TerraTorch environment
2. Register EarthMind backbone
3. Create basic configuration
4. Test backbone loading and inference

### Week 2: Compatibility Testing
1. Test with different input sizes
2. Test with TerraTorch decoders
3. Basic performance benchmarking
4. Document any compatibility issues

## Success Criteria for R&D
1. **Integration**: EarthMind backbone loads successfully in TerraTorch
2. **Compatibility**: Can process standard geospatial image inputs
3. **Output**: Produces expected tensor shapes for downstream tasks
4. **Performance**: Reasonable inference speed on available hardware

## Key Questions to Answer
1. Does EarthMind integrate smoothly with TerraTorch's architecture?
2. What are the output characteristics (shape, dtype, range)?
3. How does performance compare to standard backbones?
4. What modifications (if any) are needed for geospatial tasks?

## Next Steps After R&D
Based on testing results:
- Identify any integration issues
- Evaluate performance characteristics
- Determine if additional optimization is needed
- Plan for specific geospatial task testing (e.g., forest disturbance detection)

## Minimal Dependencies
```txt
# requirements.txt
torch
torchvision
transformers
pyyaml
```

This streamlined plan focuses on the core objective: getting EarthMind working with TerraTorch and understanding its characteristics for R&D purposes.
